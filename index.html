<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shared Drive Organization Exercise</title>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.5.0/firebase-app.js";
  import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAsGafeMKHVxAeUVAroHj-FqyPiRaDDyqE",
  authDomain: "test-769a6.firebaseapp.com",
  projectId: "test-769a6",
  storageBucket: "test-769a6.firebasestorage.app",
  messagingSenderId: "1073801314798",
  appId: "1:1073801314798:web:abd01ae67a5bc9c1eb0eff"
};

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  let tree = { id: generateId(), nodes: [] };
  let sortableInstances = new Map(); // Track sortable instances
  let nodeCounter = 0; // Better ID generation

  // Improved ID generation
  function generateId() {
    return `node_${Date.now()}_${++nodeCounter}_${Math.random().toString(36).substr(2, 9)}`;
  }

  function createNode(title) {
    return { id: generateId(), title: title || "New Item", children: [] };
  }

  function findNode(nodes, id) {
    for (const n of nodes) {
      if (n.id === id) return n;
      const child = findNode(n.children, id);
      if (child) return child;
    }
    return null;
  }

  function removeNode(nodes, id) {
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].id === id) {
        nodes.splice(i, 1);
        return true;
      }
      if (nodes[i].children.length > 0) {
        const removed = removeNode(nodes[i].children, id);
        if (removed) return true;
      }
    }
    return false;
  }

  // Clean up all sortable instances
  function destroyAllSortables() {
    sortableInstances.forEach(sortable => {
      if (sortable && sortable.destroy) {
        sortable.destroy();
      }
    });
    sortableInstances.clear();
  }

  function renderTree(tree) {
    const container = document.getElementById("trees-container");
    
    // Clean up existing sortables before re-render
    destroyAllSortables();
    container.innerHTML = "";

    const wrapper = document.createElement("div");
    wrapper.className = "tree-wrapper";
    wrapper.dataset.treeId = tree.id;

    const ul = document.createElement("ul");
    ul.className = "tree";
    wrapper.appendChild(ul);

    container.appendChild(wrapper);

    // Initialize two root nodes with placeholders if empty
    if (!tree.nodes.length) {
      const root1 = createNode("Admin");
      root1.children.push(createNode("Placeholder 1"));
      root1.children.push(createNode("Placeholder 2"));

      const root2 = createNode("Category A");
      root2.children.push(createNode("Placeholder 1"));
      root2.children.push(createNode("Placeholder 2"));

      tree.nodes.push(root1, root2);
    }

    renderNodes(ul, tree.nodes);
    initSortableForTree(ul);
  }

  function renderNodes(ul, nodes) {
    ul.innerHTML = "";
    
    nodes.forEach(node => {
      const li = document.createElement("li");
      li.dataset.nodeId = node.id;
      li.innerHTML = `
        <span class="title" contenteditable="true">${escapeHtml(node.title)}</span>
        <button class="add-btn" type="button">+Add</button>
        <button class="delete-btn" type="button">Delete</button>
      `;
      ul.appendChild(li);

      if (node.children.length) {
        const childUl = document.createElement("ul");
        childUl.className = "child-list";
        li.appendChild(childUl);
        renderNodes(childUl, node.children);
        initSortableForTree(childUl);
      }
    });

    // Add event listeners using event delegation at container level
    setupEventListeners(ul);
  }

  // Event delegation to avoid duplicate listeners
  function setupEventListeners(container) {
    // Remove existing listeners to prevent duplicates
    const newContainer = container.cloneNode(true);
    container.parentNode.replaceChild(newContainer, container);
    
    newContainer.addEventListener('input', (e) => {
      if (e.target.classList.contains('title')) {
        const nodeId = e.target.closest('li').dataset.nodeId;
        const node = findNode(tree.nodes, nodeId);
        if (node) {
          node.title = e.target.textContent.trim() || "Untitled";
        }
      }
    });

    newContainer.addEventListener('click', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      
      const nodeId = li.dataset.nodeId;
      const node = findNode(tree.nodes, nodeId);
      if (!node) return;

      if (e.target.classList.contains('add-btn')) {
        handleAddChild(node, li);
      } else if (e.target.classList.contains('delete-btn')) {
        handleDeleteNode(node, li);
      }
    });
  }

  function handleAddChild(node, li) {
    const child = createNode();
    node.children.push(child);

    let childUl = li.querySelector("ul");
    if (!childUl) {
      childUl = document.createElement("ul");
      childUl.className = "child-list";
      li.appendChild(childUl);
    }

    renderNodes(childUl, node.children);
    initSortableForTree(childUl);
  }

  function handleDeleteNode(node, li) {
    const isRootNode = tree.nodes.some(n => n.id === node.id);

    if (isRootNode && tree.nodes.length <= 1) {
      alert("Cannot delete all root nodes.");
      return;
    }

    if (node.children.length > 0) {
      if (!confirm(`This will delete "${node.title}" and all its children. Continue?`)) {
        return;
      }
    }

    // Clean up sortable for this node's children
    const childUl = li.querySelector('ul');
    if (childUl) {
      const sortableId = childUl.dataset.sortableId;
      if (sortableId && sortableInstances.has(sortableId)) {
        sortableInstances.get(sortableId).destroy();
        sortableInstances.delete(sortableId);
      }
    }

    removeNode(tree.nodes, node.id);
    li.remove();
  }

  function initSortableForTree(ul) {
    // Generate unique ID for this sortable instance
    const sortableId = generateId();
    ul.dataset.sortableId = sortableId;

    const sortable = new Sortable(ul, {
      group: 'nested',
      animation: 150,
      fallbackOnBody: true,
      swapThreshold: 0.65,
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      onStart: (evt) => {
        // Add visual feedback
        evt.item.style.opacity = '0.8';
      },
      onEnd: (evt) => {
        // Remove visual feedback
        evt.item.style.opacity = '';
        
        // Debounce the tree update
        clearTimeout(window.treeUpdateTimeout);
        window.treeUpdateTimeout = setTimeout(() => {
          updateTreeDataFromDOM();
        }, 100);
      }
    });

    sortableInstances.set(sortableId, sortable);
  }

  function updateTreeDataFromDOM() {
    const ulRoot = document.querySelector(".tree");
    if (!ulRoot) return;

    function parseUL(ul) {
      const result = [];
      Array.from(ul.children).forEach(li => {
        const nodeId = li.dataset.nodeId;
        const node = findNode(tree.nodes, nodeId);
        if (node) {
          // Create a fresh copy to avoid reference issues
          const newNode = {
            id: node.id,
            title: node.title,
            children: []
          };
          
          const childUl = li.querySelector("ul.child-list");
          if (childUl) {
            newNode.children = parseUL(childUl);
          }
          result.push(newNode);
        }
      });
      return result;
    }
    
    try {
      tree.nodes = parseUL(ulRoot);
    } catch (error) {
      console.error('Error updating tree data:', error);
      // Could add user notification here
    }
  }

  // Utility function to escape HTML
  function escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }

  window.submitHierarchy = async function() {
    const username = document.getElementById("username").value.trim() || "Anonymous";
    const submitBtn = document.querySelector('button[onclick="submitHierarchy()"]');
    
    // Disable button and show loading state
    submitBtn.disabled = true;
    submitBtn.textContent = 'Submitting...';
    
    try {
      // Final sync before submission
      updateTreeDataFromDOM();
      
      await addDoc(collection(db, "submissions"), {
        username,
        tree,
        timestamp: new Date(),
        nodeCount: countNodes(tree.nodes)
      });
      alert("Hierarchy submitted successfully!");
    } catch (e) {
      console.error("Error submitting:", e);
      alert("Failed to submit hierarchy. Please try again.");
    } finally {
      submitBtn.disabled = false;
      submitBtn.textContent = 'Submit';
    }
  };

  function countNodes(nodes) {
    let count = 0;
    nodes.forEach(node => {
      count++;
      count += countNodes(node.children);
    });
    return count;
  }

  window.onload = function() {
    renderTree(tree);
  };

  // Clean up on page unload
  window.addEventListener('beforeunload', () => {
    destroyAllSortables();
  });
</script>

<style>
body { 
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
  margin: 2rem; 
  line-height: 1.5;
}

ul { 
  list-style-type: none; 
  padding-left: 1rem; 
  margin: 0;
}

li { 
  margin: 0.25rem 0; 
  padding: 0.5rem; 
  border-radius: 6px; 
  background: #f8f9fa;
  border: 1px solid #e9ecef;
  transition: all 0.2s ease;
  position: relative;
}

li:hover { 
  background-color: #e3f2fd; 
  border-color: #2196f3;
}

li li { 
  border-left: 3px solid #ddd; 
  margin-left: 1rem; 
  margin-top: 0.5rem;
}

.sortable-chosen { 
  background-color: #bbdefb !important; 
  box-shadow: 0 4px 12px rgba(33, 150, 243, 0.3);
  transform: scale(1.02);
}

.sortable-ghost { 
  opacity: 0.4; 
  background-color: #f5f5f5 !important;
}

.sortable-drag {
  transform: rotate(5deg);
}

button { 
  margin-left: 0.5rem; 
  padding: 0.25rem 0.5rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  background: white;
  cursor: pointer;
  font-size: 0.85rem;
  transition: all 0.2s ease;
}

button:hover {
  background: #f0f0f0;
  transform: translateY(-1px);
}

button:active {
  transform: translateY(0);
}

.delete-btn:hover {
  background: #ffebee;
  border-color: #f44336;
  color: #f44336;
}

.add-btn:hover {
  background: #e8f5e8;
  border-color: #4caf50;
  color: #4caf50;
}

.title { 
  outline: none; 
  font-weight: 500;
  min-width: 50px;
  display: inline-block;
}

.title:focus {
  background: #fff3e0;
  border-radius: 2px;
  padding: 2px 4px;
}

.tree-wrapper { 
  margin-bottom: 2rem; 
  padding: 1rem; 
  border: 2px solid #dee2e6; 
  border-radius: 8px;
  background: white;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

#username {
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-bottom: 1rem;
  font-size: 1rem;
  width: 300px;
}

button[onclick="submitHierarchy()"] {
  background: #2196f3;
  color: white;
  border: none;
  padding: 0.75rem 2rem;
  font-size: 1rem;
  border-radius: 6px;
  margin-top: 1rem;
}

button[onclick="submitHierarchy()"]:hover:not(:disabled) {
  background: #1976d2;
}

button[onclick="submitHierarchy()"]:disabled {
  background: #ccc;
  cursor: not-allowed;
}
</style>
</head>
<body>

<h1>Shared Drive Organization Exercise</h1>

<p>Use the box below to create a structure for our Shared Drive. Add or delete items using the buttons. Drag items to organize them inside or outside the highlighted areas. Click on titles to edit them. You may focus on items/areas more relevant to your work (or be comprehensive if you like a challenge!).<br><br>
Please do not submit confidential information in this form. Where relevant, consider using more general terms or placeholder names like "Partner A".<br><br>
Note: Your changes are NOT saved automatically. Be sure to click <b>Submit</b> when finished, or your work will be lost.</p>

<input type="text" id="username" placeholder="Enter your name">
<div id="trees-container"></div>
<button onclick="submitHierarchy()">Submit</button>

</body>
</html>
