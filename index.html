<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Shared Drive Organization Exercise</title>
<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.5.0/firebase-app.js";
  import { getFirestore, collection, addDoc } from "https://www.gstatic.com/firebasejs/10.5.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyAsGafeMKHVxAeUVAroHj-FqyPiRaDDyqE",
  authDomain: "test-769a6.firebaseapp.com",
  projectId: "test-769a6",
  storageBucket: "test-769a6.firebasestorage.app",
  messagingSenderId: "1073801314798",
  appId: "1:1073801314798:web:abd01ae67a5bc9c1eb0eff"
};

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);

  let tree = { id: Date.now() + Math.random(), nodes: [] };
  let idCounter = 0; // Add counter to make IDs more unique

  function createNode(title) {
    return { id: Date.now() + Math.random() + (++idCounter), title: title || "New Item", children: [] };
  }

  function findNode(nodes, id) {
    for (const n of nodes) {
      if (n.id === id) return n;
      const child = findNode(n.children, id);
      if (child) return child;
    }
    return null;
  }

  function removeNode(nodes, id) {
    for (let i = 0; i < nodes.length; i++) {
      if (nodes[i].id === id) {
        nodes.splice(i, 1);
        return true;
      }
      if (nodes[i].children.length > 0) {
        const removed = removeNode(nodes[i].children, id);
        if (removed) return true;
      }
    }
    return false;
  }

  function renderTree(tree) {
    console.log("renderTree called with:", tree);
    const container = document.getElementById("trees-container");
    console.log("Container found:", container);
    
    container.innerHTML = "";

    const wrapper = document.createElement("div");
    wrapper.className = "tree-wrapper";
    wrapper.dataset.treeId = tree.id;

    const ul = document.createElement("ul");
    ul.className = "tree";
    wrapper.appendChild(ul);

    container.appendChild(wrapper);
    console.log("Wrapper and UL added to container");

    // Initialize two root nodes with placeholders if empty
    if (!tree.nodes.length) {
      console.log("Initializing default nodes");
      const root1 = createNode("Admin");
      root1.children.push(createNode("Placeholder 1"));
      root1.children.push(createNode("Placeholder 2"));

      const root2 = createNode("Category A");
      root2.children.push(createNode("Placeholder 1"));
      root2.children.push(createNode("Placeholder 2"));

      tree.nodes.push(root1, root2);
      console.log("Default nodes created:", tree.nodes);
    }

    renderNodes(ul, tree.nodes);
    initSortableForTree(ul);
    console.log("renderTree completed");
  }

  function renderNodes(ul, nodes) {
    ul.innerHTML = "";
    nodes.forEach(node => {
      const li = document.createElement("li");
      li.dataset.nodeId = node.id;
      li.innerHTML = `
        <span class="title" contenteditable="true">${node.title}</span>
        <button class="add-btn">+Add</button>
        <button class="delete-btn">Delete</button>
      `;
      ul.appendChild(li);

      if (node.children.length) {
        const childUl = document.createElement("ul");
        li.appendChild(childUl);
        renderNodes(childUl, node.children);
        initSortableForTree(childUl);
      }

      // Update title
      const titleSpan = li.querySelector(".title");
      titleSpan.addEventListener("input", e => {
        node.title = e.target.textContent.trim() || "Untitled";
      });

      // Prevent multiple event listeners on the same element
      titleSpan.addEventListener("blur", e => {
        // Clean up the text content
        e.target.textContent = e.target.textContent.trim() || "Untitled";
      });

      // Add child
      const addBtn = li.querySelector(".add-btn");
      addBtn.addEventListener("click", () => {
        const child = createNode();
        node.children.push(child);

        let childUl = li.querySelector("ul");
        if (!childUl) {
          childUl = document.createElement("ul");
          li.appendChild(childUl);
        }

        renderNodes(childUl, node.children);
        initSortableForTree(childUl);
      });

      // Delete node
      const deleteBtn = li.querySelector(".delete-btn");
      deleteBtn.addEventListener("click", () => {
        const ulRoot = document.querySelector(".tree");
        
        // Update tree data before deletion
        updateTreeDataFromDOM(ulRoot);

        const isRootNode = tree.nodes.some(n => n.id === node.id);

        if (isRootNode && tree.nodes.length <= 1) {
          alert("Cannot delete all root nodes.");
          return;
        }

        // Remove from data structure
        if (removeNode(tree.nodes, node.id)) {
          li.remove();
          // Update the tree data after DOM change
          setTimeout(() => updateTreeDataFromDOM(ulRoot), 0);
        }
      });
    });
  }

  function initSortableForTree(ul) {
    // Check if sortable already exists
    if (ul._sortable) {
      ul._sortable.destroy();
    }

    const sortable = new Sortable(ul, {
      group: 'nested',
      animation: 150,
      fallbackOnBody: true,
      swapThreshold: 0.65,
      onEnd: () => {
        const ulRoot = document.querySelector(".tree");
        // Use setTimeout to ensure DOM is settled
        setTimeout(() => updateTreeDataFromDOM(ulRoot), 50);
      }
    });

    // Store reference to sortable for cleanup
    ul._sortable = sortable;
  }

  function updateTreeDataFromDOM(ul) {
    if (!ul) return;

    function parseUL(ul) {
      const result = [];
      Array.from(ul.children).forEach(li => {
        const nodeId = parseFloat(li.dataset.nodeId); // Convert back to number
        const node = findNode(tree.nodes, nodeId);
        if (node) {
          // Update children array
          const childUl = li.querySelector("ul");
          if (childUl) {
            node.children = parseUL(childUl);
          } else {
            node.children = [];
          }
          result.push(node);
        }
      });
      return result;
    }
    
    try {
      tree.nodes = parseUL(ul);
    } catch (error) {
      console.error("Error updating tree data:", error);
    }
  }

  window.submitHierarchy = async function() {
    const username = document.getElementById("username").value || "Anonymous";
    
    // Final sync before submission
    const ulRoot = document.querySelector(".tree");
    updateTreeDataFromDOM(ulRoot);
    
    try {
      await addDoc(collection(db, "submissions"), {
        username,
        tree,
        timestamp: new Date()
      });
      alert("Hierarchy submitted successfully!");
    } catch (e) {
      console.error("Error submitting:", e);
      alert("Failed to submit hierarchy.");
    }
  };

  window.onload = function() {
    renderTree(tree);
  };
</script>

<style>
body { font-family: sans-serif; margin: 2rem; }
ul { list-style-type: none; padding-left: 1rem; }
li { margin: 0.1rem 0; padding: 0.25rem 0.5rem; border-radius: 4px; }
li:nth-child(odd) { background: #f0f0f0; }
li:nth-child(even) { background: #fafafa; }
li li { border-left: 2px solid #ccc; margin-left: 0.5rem; padding-left: 0.5rem; }
li:hover { background-color: #d0ebff; }
.sortable-chosen { background-color: #a0d2ff !important; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
.sortable-ghost { opacity: 0.5; }
button { margin-left: 0.5rem; }
.title { outline: none; }
.tree-wrapper { margin-bottom: 1rem; padding: 0.5rem; border: 1px solid #aaa; border-radius: 6px; }
</style>
</head>
<body>

<h1>Shared Drive Organization Exercise</h1>

<p>Use the box below to create a structure for our Shared Drive. Add or delete items using the buttons. Drag items to organize them inside or outside the highlighted areas. Click on titles to edit them. You may focus on items/areas more relevant to your work (or be comprehensive if you like a challenge!).<br><br>
Please do not submit confidential information in this form. Where relevant, consider using more general terms or placeholder names like "Partner A".<br><br>
Note: Your changes are NOT saved automatically. Be sure to click <b>Submit</b> when finished, or your work will be lost.</p>

<input type="text" id="username" placeholder="Enter your name">
<div id="trees-container"></div>
<button onclick="submitHierarchy()">Submit</button>

</body>
</html>
